// Copyright (C) 2014 by Benjamin Chr√©tien, CNRS-LIRMM.
//
// This file is part of the roboptim.
//
// roboptim is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// roboptim is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with roboptim.  If not, see <http://www.gnu.org/licenses/>.

#include "roboptim/core/config.hh"
#include "config.h"

#include <iostream>

#include <roboptim/core/visualization/matplotlib.hh>
#include <roboptim/core/visualization/matplotlib-commands.hh>
#include <roboptim/core/indent.hh>

namespace roboptim
{
  namespace visualization
  {
    Matplotlib::Matplotlib (std::pair<int, int> multiplot, bool with_header)
      : withHeader_ (with_header),
        multiplot_ (multiplot)
    {
      resetImports ();
    }

    Matplotlib::~Matplotlib ()
    {
    }

    bool& Matplotlib::withHeader ()
    {
      return withHeader_;
    }

    bool Matplotlib::withHeader () const
    {
      return withHeader_;
    }

    std::pair<int, int>& Matplotlib::multiplot ()
    {
      return multiplot_;
    }

    std::pair<int, int> Matplotlib::multiplot () const
    {
      return multiplot_;
    }

    void
    Matplotlib::resetImports ()
    {
      imports_.clear ();
      imports_.push_back (std::string ("matplotlib"));
      imports_.push_back (std::string ("matplotlib.pyplot as plt"));
      imports_.push_back (std::string ("numpy as np"));
    }

    void
    Matplotlib::push_command (const matplotlib::Command& cmd)
    {
      commands_.push_back (cmd);
    }

    void
    Matplotlib::push_import (const matplotlib::Import& import)
    {
      imports_.push_back (import);
    }

    std::ostream&
    Matplotlib::print (std::ostream& o) const
    {
      typedef std::vector<matplotlib::Import>::const_iterator citer_imp_t;
      typedef std::vector<matplotlib::Command>::const_iterator citer_cmd_t;
      int n = 1; // number of the plot

      if (withHeader_)
	{
	  o << "#!/usr/bin/env python" << std::endl;
	  o << "# Generated by " PACKAGE_NAME << std::endl;

	  for (citer_imp_t it = imports_.begin (); it != imports_.end (); ++it)
	    o << it->command () << std::endl;

	  o << std::endl;
	  o << "fig = plt.figure()" << std::endl;
	  if (multiplot().first == 1 && multiplot().second == 1)
	    o << "ax = plt.subplot(111)" << std::endl;
	  o << std::endl;
	}

      for (citer_cmd_t it = commands_.begin (); it != commands_.end (); ++it)
	{
	  if (!it->isPlot() || (multiplot().first == 1 && multiplot().second == 1))
	    o << it->command () << std::endl;
	  else
	    {
	      assert (multiplot().first > 0 && multiplot().second > 0);
	      o << "ax" << n << " = plt.subplot(" << multiplot().first
		<< ", " << multiplot().second << ", " << n << ")" << std::endl;
	      o << it->command () << std::endl;
	      o << "box = ax" << n << ".get_position()" << std::endl;
	      o << "ax" << n << ".set_position([box.x0, box.y0, box.width * 0.8, box.height])" << std::endl;
	      o << "ax" << n << ".legend(loc='center left', bbox_to_anchor=(1, 0.5))" << std::endl;
	      ++n;
	    }
	}

      o << std::endl;

      if (withHeader())
	{
	  if (multiplot().first == 1 && multiplot().second == 1)
	    {
	      // Display legend on the right of the image
	      o << "box = ax.get_position()" << std::endl;
	      o << "ax.set_position([box.x0, box.y0, box.width * 0.8, box.height])" << std::endl;
	      o << "ax.legend(loc='center left', bbox_to_anchor=(1, 0.5))" << std::endl;
	    }

	  // Show image
	  o << "fig.tight_layout()" << std::endl;
	  o << "plt.show()" << std::endl;
	}

      return o;
    }

    Matplotlib&
    Matplotlib::operator << (matplotlib::Command cmd)
    {
      push_command (cmd);
      return *this;
    }

    Matplotlib&
    Matplotlib::operator << (matplotlib::Import import)
    {
      push_import (import);
      return *this;
    }

    std::ostream&
    operator<< (std::ostream& o, const Matplotlib& ml)
    {
      return ml.print (o);
    }

    void
    Matplotlib::clear ()
    {
      resetImports ();
      commands_.clear ();
    }
  } // end of namespace visualization.
} // end of namespace roboptim.
